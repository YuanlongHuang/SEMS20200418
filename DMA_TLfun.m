function fun_x = DMA_TLfun(flag,a,w_i,w_e,tau_s,Agamma,gamma)
% flag = [TorL UorD];
% This function returns TorL and UorD based expression for fun_x
% TorL: 't' or 'l', stand for solve tau or lambda first
% UorD: 'u' or 'd', stand for up or down scan
% use MATLAB built-in function Li_polylog(n,x)
% created: 2019/08/28, YH

switch flag
    case 'tu' % upscan + tau
        % omega_i = omega_e + lambda*(1-exp(-tx));
        fun_x = @(tx) a-tau_s*Agamma*( ...
            (1-gamma)*(tx.*log((-w_e*exp(-tx)+w_i)./(1-exp(-tx))) ...
            -Li_polylog(2,(-w_e+w_i)./(-w_e*exp(-tx)+w_i)) ...
            +Li_polylog(2,(-w_e+w_i)*exp(-tx)./(-w_e*exp(-tx)+w_i))) ...
            -(tx.*(1-(-w_e*exp(-tx)+w_i)./(1-exp(-tx))) ...
            +w_i-w_e)*log(gamma));
    case 'td' % downscan + tau
        % omega_i = omega_e - lambda*(1-exp(tx));
        fun_x = @(tx) a-tau_s*Agamma*( ...
            (1-gamma)*(tx.*log((w_e-w_i)./(1-exp(tx))) ...
            +tx.^2/2 ...
            -Li_polylog(2,(w_e*exp(tx)-w_i)/(w_e-w_i)) ...
            +Li_polylog(2,(w_e*exp(tx)-w_i)./(w_e-w_i)*exp(-tx))) ...
            -(tx.*(1+(w_e*exp(tx)-w_i)./(1-exp(tx))) ...
            -w_i+w_e)*log(gamma));
    case 'lu' % upscan + lambda
        % omega_i = omega_e + lx*(1-exp(-tau_t));
        fun_x = @(lx) a-tau_s*Agamma*( ...
            (1-gamma)*(log(lx./(-w_i+w_e+lx)).*log(w_e+lx) ...
            -Li_polylog(2,lx./(w_e+lx)) ...
            +Li_polylog(2,(-w_i+w_e+lx)./(w_e+lx))) ...
            -(log(lx./(-w_i+w_e+lx)).*(1-w_e-lx) ...
            +w_i-w_e)*log(gamma));
    case 'ld' % downscan + lambda
        % omega_i = omega_e - lx*(1-exp(tau_t));
        fun_x = @(lx) a-tau_s*Agamma*( ...
            (1-gamma)*(log((w_i-w_e+lx)./lx).*log(lx) ...
            +(log((w_i-w_e+lx)./lx)).^2/2 ...
            -Li_polylog(2,(-w_e+lx)./lx) ...
            +Li_polylog(2,(-w_e+lx)./(w_i-w_e+lx))) ...
            -(log((w_i-w_e+lx)./lx).*(1-w_e+lx) ...
            -w_i+w_e)*log(gamma));
end

